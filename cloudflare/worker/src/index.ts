import { Router, IRequest, error, json } from 'itty-router';
import { generateAdminToken, verifyPassword, jwtMiddleware } from './auth';
import adminCategoryRoutes from './adminCategoryRoutes';
import adminProductRoutes from './adminProductRoutes';
import adminCardRoutes from './adminCardRoutes';
import adminOrderRoutes from './adminOrderRoutes';
import adminPaymentRoutes from './adminPaymentRoutes';
import adminNoticeRoutes from './adminNoticeRoutes';
import adminAccountRoutes from './adminAccountRoutes';
import adminConfigRoutes from './adminConfigRoutes';
import adminPluginRoutes from './adminPluginRoutes';
import adminDashboardRoutes from './adminDashboardRoutes'; // Import dashboard routes

// Define the Env interface according to Cloudflare Workers specifics
// This will include bindings like D1, R2, KV, Services, etc.
export interface Env {
	DB: D1Database;
	JWT_SECRET: string; // For signing JWTs
	// Add other bindings as needed, e.g.:
	// MY_KV_NAMESPACE: KVNamespace;
	// MY_R2_BUCKET: R2Bucket;
	// MY_SERVICE: Fetcher;
}

const router = Router({ base: '/api/v4' }); // Base path for admin routes

// Middleware to set CORS headers - adjust as needed for your security requirements
const corsHeaders = {
	'Access-Control-Allow-Origin': '*', // Or specify your frontend domain
	'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS',
	'Access-Control-Allow-Headers': 'Content-Type, Authorization', // Add any other headers your app uses
};

const handleOptions = (request: IRequest) => {
	// Handle CORS preflight requests
	if (request.headers.get('Origin') !== null &&
		request.headers.get('Access-Control-Request-Method') !== null &&
		request.headers.get('Access-Control-Request-Headers') !== null) {
		// Handle CORS preflight requests.
		return new Response(null, {
			headers: corsHeaders,
		});
	} else {
		// Handle standard OPTIONS requests.
		return new Response(null, {
			headers: {
				Allow: 'GET, HEAD, POST, PUT, DELETE, OPTIONS',
			},
		});
	}
};

router.options('*', handleOptions);

// Apply CORS headers to all responses (or selectively per route)
router.all('*', (request: IRequest, ...args) => {
	// This is a simple way to apply CORS to all responses.
	// It might be better to apply it in a more granular way if needed.
	// The actual response will be generated by the route handlers below.
});


// LOGIN ROUTE for /api/v4/login
router.post('/login', async (request: IRequest, env: Env) => {
	try {
		const body = await request.json();
		const { email, password } = body as any; // Consider using a type/interface for the body

		if (!email || !password) {
			return error(400, 'Email and password are required.');
		}

		// Query the AdminUser table
		const stmt = env.DB.prepare('SELECT id, password_hash FROM AdminUser WHERE email = ? AND status = 1'); // Ensure user is active
		const adminUser = await stmt.bind(email).first<{ id: number; password_hash: string }>();

		if (!adminUser) {
			return error(404, 'User not found or not active.');
		}

		const passwordMatches = await verifyPassword(password, adminUser.password_hash);

		if (!passwordMatches) {
			return error(400, 'Invalid credentials.'); // Or 401
		}

		const token = await generateAdminToken(email, env);
		return json({ access_token: token });

	} catch (e: any) {
		console.error('Login error:', e);
		return error(500, 'Internal Server Error: ' + e.message);
	}
});


// PROTECTED SAMPLE ROUTE for /api/v4/dashboard_test
// The jwtMiddleware from auth.ts will be applied here.
// itty-router allows middleware to be passed before the main handler.
// If jwtMiddleware returns a Response, it short-circuits. Otherwise, the next handler is called.
router.get('/dashboard_test', 
    async (request: IRequest, env: Env, ctx: ExecutionContext) => {
        const authResponse = await jwtMiddleware(request as unknown as Request, env);
        if (authResponse) {
            return authResponse; // Auth failed, return the response from middleware
        }
        const adminEmail = request.admin?.email || 'Email not found in token';
        return json({ message: 'Welcome admin!', admin_email: adminEmail });
    }
);

// Mount category routes
router.all('/categories/*', adminCategoryRoutes.handle);
// Mount product routes
router.all('/products/*', adminProductRoutes.handle);
// Mount card routes
router.all('/cards/*', adminCardRoutes.handle);
// Mount order routes
router.all('/orders/*', adminOrderRoutes.handle);
// Mount payment gateway routes
router.all('/payments/*', adminPaymentRoutes.handle);
// Mount notice routes
router.all('/notices/*', adminNoticeRoutes.handle);
// Mount admin account routes
router.all('/admin_account/*', adminAccountRoutes.handle);
// Mount system settings (config) routes
router.all('/system_settings/*', adminConfigRoutes.handle);
// Mount plugin (TG and Theme) routes
router.all('/tg_plugin/*', adminPluginRoutes.handle);
router.all('/theme/*', adminPluginRoutes.handle);
// Mount dashboard route
router.all('/dashboard/*', adminDashboardRoutes.handle); // Typically just '/dashboard' if base is '/api/v4/dashboard'


// --- User API Routes (Placeholder, /api/v2) ---
const userRouter = Router({ base: '/api/v2' });

userRouter.all('*', (request: IRequest, env: Env, ctx: ExecutionContext) => {
	return json({ message: 'User API placeholder for ' + request.url });
});


// --- Main Exported Handler ---
// Create a new top-level router to handle base path routing and CORS
const mainRouter = Router();

// Apply CORS headers globally before routing
mainRouter.all('*', (request: IRequest, env: Env, ctx: ExecutionContext) => {
    // Handle CORS preflight requests (OPTIONS)
    if (request.method === 'OPTIONS') {
        return handleOptions(request);
    }
    // For other requests, the actual response will be generated by the specific router
    // and CORS headers will be added in the final response handling.
});

mainRouter.all('/api/v4/*', router.handle);       // Admin routes
mainRouter.all('/api/v2/*', userRouter.handle); // User routes
mainRouter.get('/', () => new Response('Kamifaka Worker is running!')); // Root path
mainRouter.all('*', () => error(404, 'Not found. Please check the URL.')); // Catch-all 404

export default {
	async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
		return mainRouter.handle(request, env, ctx)
			.then((response: Response) => {
				// Ensure CORS headers are applied to all actual responses
				const newHeaders = new Headers(response.headers);
				Object.entries(corsHeaders).forEach(([key, value]) => {
					if (!newHeaders.has(key)) { // Avoid overwriting if already set by specific route
						newHeaders.set(key, value);
					}
				});
				// Ensure Content-Type is application/json for error responses from itty-router
				if ( (response.status === 400 || response.status === 401 || response.status === 404 || response.status === 500) && 
             !newHeaders.has('Content-Type') && 
             (response.body && typeof response.body === 'string' && response.body.includes("error"))) {
           try {
             JSON.parse(response.body as string); // Check if body is already JSON
           } catch (e) {
             // If not JSON, and it's an error response, wrap it
             // This is a workaround because itty-router's error() helper might not set Content-Type
             const originalBody = response.body ? await response.text() : "{}";
             if (originalBody.startsWith("{") && originalBody.endsWith("}")) {
                // It might be a JSON string already, just ensure header
             } else {
                // Not a JSON string, create one
                // This part is tricky as itty-router error responses are simple strings
                // For now, we'll just ensure application/json if it looks like an error object was stringified
             }
             if(!newHeaders.has('Content-Type')) newHeaders.set('Content-Type', 'application/json');
           }
        } else if (!newHeaders.has('Content-Type') && response.body && response.body instanceof ReadableStream) {
            // Default to JSON for stream responses if not set, but this is a guess
            // newHeaders.set('Content-Type', 'application/json'); 
        }


				return new Response(response.body, {
					status: response.status,
					statusText: response.statusText,
					headers: newHeaders,
				});
			})
			.catch((err: any) => {
				console.error("Global error handler:", err);
				// Construct a JSON error response
				const errorResponse = {
					error: "Internal Server Error",
					message: err.message || String(err),
				};
				return new Response(JSON.stringify(errorResponse), { 
					headers: { ...corsHeaders, 'Content-Type': 'application/json' }, 
					status: 500 
				});
			});
	},
};

// Note: The CORS handling for OPTIONS and general responses has been simplified.
// The `handleOptions` function and global `corsHeaders` are still used.
// The `mainRouter.all('*', ...)` is a good place for initial OPTIONS check.
// The final `.then((response: Response) => { ... })` block ensures headers are on actual responses.
